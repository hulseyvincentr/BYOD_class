# calculate_wav_spectrogram_amplitude_and_periodicity.py# ======================================================from __future__ import annotationsfrom pathlib import Pathimport numpy as npimport matplotlib.pyplot as pltfrom scipy.ndimage import gaussian_filter1dfrom scipy.signal import spectrogram as _spectrogram   # avoid name clashfrom load_wav_gen_spec import generate_spectrogram_from_wav# ────────────────────────────────────────────────────────────────────────# Data container – with auto-detected spans# ────────────────────────────────────────────────────────────────────────class SpectrogramData:    def __init__(        self,        spectrogram: np.ndarray,        frequencies: np.ndarray,        times: np.ndarray,        z_log_amp_band_unsmoothed: np.ndarray,        z_log_amp_band_smoothed: np.ndarray,        envelope_spectrogram: np.ndarray,        periodicity_full: np.ndarray,        periodicity_bandpass: np.ndarray,        amplitude_detected_song_times: list[tuple[float, float]],        periodicity_detected_song_times: list[tuple[float, float]],    ):        self.spectrogram                     = spectrogram        self.frequencies                     = frequencies        self.times                           = times        self.z_log_amp_band_unsmoothed       = z_log_amp_band_unsmoothed        self.z_log_amp_band_smoothed         = z_log_amp_band_smoothed        self.envelope_spectrogram            = envelope_spectrogram        self.periodicity_full                = periodicity_full        self.periodicity_bandpass            = periodicity_bandpass        self.amplitude_detected_song_times   = amplitude_detected_song_times        self.periodicity_detected_song_times = periodicity_detected_song_times# ────────────────────────────────────────────────────────────────────────# Helper – convert boolean mask → (start, end) spans# ────────────────────────────────────────────────────────────────────────def _mask_to_spans(mask: np.ndarray, time_axis: np.ndarray) -> list[tuple[float, float]]:    spans, in_span = [], False    for i, flag in enumerate(mask):        if flag and not in_span:            in_span, t0 = True, time_axis[i]        elif not flag and in_span:            spans.append((t0, time_axis[i]))            in_span = False    if in_span:        spans.append((t0, time_axis[-1]))    return spans# ────────────────────────────────────────────────────────────────────────# Main function – wav only, auto-detected song spans# ────────────────────────────────────────────────────────────────────────def calculate_wav_spectrogram_amplitude_and_periodicity(    wav_path: str | Path,    *,    plot_amplitude_figure: bool = True,    plot_periodicity_figure: bool = True,    amp_low_bandpass: float = 700,    amp_high_bandpass: float = 7000,    amp_threshold: float = -0.5,    low_mod: float = 10,    high_mod: float = 90,    smoothing_sigma_amplitude: float = 30,    smoothing_sigma_periodicity: float = 1,    power_threshold: float = 0.05, #periodicity threshold) -> SpectrogramData:    """Feature extraction **only** from a raw .wav recording."""    wav_path = Path(wav_path)    if wav_path.suffix.lower() != ".wav":        raise ValueError(f"{wav_path} does not appear to be a .wav file.")    # 1) build spectrogram from wav ------------------------------------------------    wav_dict   = generate_spectrogram_from_wav(wav_path)    spectrogram  = wav_dict["spectrogram"]    frequencies  = wav_dict["frequencies"]    times        = wav_dict["times"]    # --- NEW: realign so the first bin is exactly 0 s ----------------------------    t0 = times[0]    if t0 > 0:        # avoid unnecessary copy        times = times - t0            # shift main time axis            eps = np.finfo(float).eps    # 2) amplitude trace -----------------------------------------------------------    band_mask  = (frequencies >= amp_low_bandpass) & (frequencies <= amp_high_bandpass)    amp_band   = (10 ** (spectrogram[band_mask, :] / 10)).sum(axis=0)    log_amp    = np.log10(amp_band + eps)    z_log_raw  = (log_amp - log_amp.mean()) / log_amp.std()    z_log_smooth = gaussian_filter1d(z_log_raw, sigma=smoothing_sigma_amplitude)    amplitude_detected_mask  = z_log_smooth > amp_threshold    amplitude_spans = _mask_to_spans(amplitude_detected_mask, times)    # 3) envelope spectrogram & periodicity ----------------------------------------    dt     = np.mean(np.diff(times)) if len(times) > 1 else 1 / 100.0    amp_fs = 1.0 / dt    nperseg  = 128    pad_len  = nperseg // 2    trace_pad = np.pad(z_log_raw, pad_len, mode="edge")    f_env, t_env_raw, S_env = _spectrogram(        trace_pad, fs=amp_fs, window="hann",        nperseg=nperseg, noverlap=96,    )    t_env = t_env_raw - (pad_len / amp_fs) -t0    valid = (t_env >= times[0]) & (t_env <= times[-1])    t_env = t_env[valid]    S_env = S_env[:, valid]    S_env_norm = (S_env - S_env.min()) / (S_env.max() - S_env.min() + eps)    pow_full       = S_env_norm.sum(axis=0)    pow_full_norm  = (pow_full - pow_full.min()) / (pow_full.max() - pow_full.min() + eps)    periodicity_full = gaussian_filter1d(pow_full_norm, sigma=smoothing_sigma_periodicity)    mod_mask = (f_env >= low_mod) & (f_env <= high_mod)    pow_bp       = S_env_norm[mod_mask].sum(axis=0)    pow_bp_norm  = (pow_bp - pow_bp.min()) / (pow_bp.max() - pow_bp.min() + eps)    periodicity_bandpass = gaussian_filter1d(pow_bp_norm, sigma=smoothing_sigma_periodicity)    periodicity_detected_mask = periodicity_bandpass > power_threshold    periodicity_spans = _mask_to_spans(periodicity_detected_mask, t_env)    # 4) plotting ------------------------------------------------------------------    if plot_amplitude_figure:        fig, axs = plt.subplots(2, 1, figsize=(10, 6), sharex=True,                                gridspec_kw=dict(height_ratios=[1, 2]))        ticks = np.linspace(times[0], times[-1], 6)        # panel 1 – amplitude trace        axs[0].plot(times, z_log_raw,   color="gray", alpha=0.5,                    label="Bandpass filtered")        axs[0].plot(times, z_log_smooth, color="black",                    label=f"Smoothed (σ={smoothing_sigma_amplitude})")        axs[0].axhline(amp_threshold, color="red", ls="--",                       label="Threshold")        axs[0].set_ylabel("z-log Σ power")        for start, end in amplitude_spans:            axs[0].axvspan(start, end, color="yellow", alpha=0.3)        axs[0].legend(fontsize="x-small", loc="upper right")        # panel 2 – original spectrogram        axs[1].pcolormesh(times, frequencies, spectrogram,                          shading="auto", cmap="binary")        axs[1].set_ylabel("Frequency (Hz)")        axs[1].set_ylim(amp_low_bandpass, amp_high_bandpass + 50)        axs[1].set_xlabel("Time (s)")        for start, end in amplitude_spans:            axs[1].axvspan(start, end, color="yellow", alpha=0.3)        for ax in axs:            ax.set_xticks(ticks)            ax.tick_params(axis="x", labelbottom=True)        fig.suptitle(f"Amplitude-based detection\n{wav_path.name}",                     y=1.02, fontsize=14, fontweight="bold")        fig.tight_layout()        plt.show()    if plot_periodicity_figure:        fig, axs = plt.subplots(4, 1, figsize=(10, 9), sharex=True,                                gridspec_kw=dict(height_ratios=[1, 1.5, 1, 2]))        ticks = np.linspace(times[0], times[-1], 6)        # panel 1 – amplitude trace (raw)        axs[0].plot(times, z_log_raw, color="black", alpha=0.5)        axs[0].set_ylabel("z-log Σ power")        # panel 2 – envelope spectrogram        axs[1].imshow(S_env_norm, origin="lower", aspect="auto",                      extent=[times[0], times[-1], f_env[0], f_env[-1]],                      cmap="binary")        axs[1].set_ylim(0, max(high_mod * 1.1, 100))        axs[1].set_ylabel("Mod freq (Hz)")        axs[1].axhline(low_mod,  color="red", ls="--")        axs[1].axhline(high_mod, color="red", ls="--")        # panel 3 – band-pass periodicity trace        axs[2].plot(t_env, pow_bp_norm,          color="gray", alpha=0.6,                    label="Bandpass filtered")        axs[2].plot(t_env, periodicity_bandpass, color="black",                    label=f"Smoothed (σ={smoothing_sigma_periodicity})")        axs[2].axhline(power_threshold, color="red", ls="--",                       label="Threshold")        axs[2].set_ylabel("Periodicity")        axs[2].legend(fontsize="x-small")        for start, end in periodicity_spans:            axs[2].axvspan(start, end, color="yellow", alpha=0.3)        # panel 4 – original spectrogram        axs[3].pcolormesh(times, frequencies, spectrogram,                          shading="auto", cmap="binary")        axs[3].set_ylabel("Frequency (Hz)")        axs[3].set_ylim(0, amp_high_bandpass + 50)        axs[3].set_xlabel("Time (s)")        for start, end in periodicity_spans:            axs[3].axvspan(start, end, color="yellow", alpha=0.3)        for ax in axs:            ax.set_xticks(ticks)            ax.tick_params(axis="x", labelbottom=True)        fig.suptitle(f"Periodicity-based detection\n{wav_path.name}",                     y=1.02, fontsize=14, fontweight="bold")        fig.tight_layout()        plt.show()    # 5) package results -----------------------------------------------------------    return SpectrogramData(        spectrogram                     = spectrogram,        frequencies                     = frequencies,        times                           = times,        z_log_amp_band_unsmoothed       = z_log_raw,        z_log_amp_band_smoothed         = z_log_smooth,        envelope_spectrogram            = S_env_norm,        periodicity_full                = periodicity_full,        periodicity_bandpass            = periodicity_bandpass,        amplitude_detected_song_times   = amplitude_spans,        periodicity_detected_song_times = periodicity_spans,    )#how to use:# result = generate_spectrogram_from_wav(wav_path)# amp_per_results = calculate_wav_spectrogram_amplitude_and_periodicity(wav_path, plot_amplitude_figure=True, plot_periodicity_figure=True)