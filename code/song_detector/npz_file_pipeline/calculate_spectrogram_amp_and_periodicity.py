#!/usr/bin/env python# -*- coding: utf-8 -*-"""Calculate periodicity and other acoustic features from a pre-computedspectrogram (.npz) **or** from an in-memory dict produced bygenerate_spectrogram_from_wav().  Optionally draws a 4-panel diagnosticfigure.Returns a SpectrogramData object with:    spectrogram            (2-D array)    frequencies, times     (1-D arrays)    songs, starts, ends    (mask + segment bounds; empty if not supplied)    z_log_amp_trace        (1-D)    envelope_spectrogram   (2-D)    periodicity_full       (1-D)    periodicity_bandpass   (1-D)"""from __future__ import annotationsfrom pathlib import Pathimport numpy as npimport matplotlib.pyplot as pltfrom scipy.ndimage import gaussian_filter1dfrom scipy.signal import spectrogram as _spectrogram  # avoid name clash# ════════════════════════════════════════════════════════════════# Data container# ════════════════════════════════════════════════════════════════class SpectrogramData:    def __init__(        self,         spectrogram: np.ndarray,        frequencies: np.ndarray,        times: np.ndarray,        groundtruth_songs: np.ndarray,        groundtruth_song_starts: np.ndarray,        groundtruth_song_ends: np.ndarray,        z_log_amp_band_unsmoothed: np.ndarray,        z_log_amp_band_smoothed: np.ndarray,        amplitude_detected_song_times: list[tuple[float, float]],        envelope_spectrogram: np.ndarray,        periodicity_full: np.ndarray,        periodicity_bandpass: np.ndarray,        periodicity_detected_song_times: list[tuple[float, float]]    ):        self.spectrogram = spectrogram        self.frequencies = frequencies        self.times = times        self.groundtruth_songs = groundtruth_songs        self.groundtruth_song_starts = groundtruth_song_starts        self.groundtruth_song_ends = groundtruth_song_ends        self.z_log_amp_band_unsmoothed = z_log_amp_band_unsmoothed        self.z_log_amp_band_smoothed = z_log_amp_band_smoothed        self.amplitude_detected_song_times = amplitude_detected_song_times        self.envelope_spectrogram = envelope_spectrogram        self.periodicity_full = periodicity_full        self.periodicity_bandpass = periodicity_bandpass        self.periodicity_detected_song_times = periodicity_detected_song_times# ════════════════════════════════════════════════════════════════# Main function# ════════════════════════════════════════════════════════════════def calculate_spectrogram_amplitude_and_periodicity(    input_data: str | dict,    plot_amplitude_figure: bool = True,    plot_periodicity_figure: bool = True,    amp_low_bandpass: float = 0,    amp_high_bandpass: float = 500,    amp_threshold = -0.9,    low_mod: float = 10,    high_mod: float = 90,    smoothing_sigma_amplitude: float = 10,    smoothing_sigma_periodicity: float = 0.7,    power_threshold: float = 0.15,    segment_duration: float = 10,   # ← only used as a *fallback* if no 't' axis exists) -> SpectrogramData:    """    Parameters    ----------    input_data : str | dict        • Path to a .npz with keys ‘s’, ‘f’, ‘t’, ‘song’        • OR a dict {'spectrogram', 'frequencies', 'times'} from          generate_spectrogram_from_wav().    """    eps = np.finfo(float).eps    # ── 1. Load / unpack ───────────────────────────────────────    if isinstance(input_data, (str, bytes)):        with np.load(input_data, allow_pickle=True) as data:            spectrogram = data["s"]            frequencies = (                data["f"] if "f" in data.files else np.arange(spectrogram.shape[0])            )            times = (                data["t"]                if "t" in data.files                else np.linspace(                    0, segment_duration, spectrogram.shape[1], endpoint=False                )            )            groundtruth_songs = data["song"].astype(bool) #load in George's song labeled time bins (1=song, 0=no song)     else:        raise TypeError(            "input_data must be a file path or a dict produced by generate_spectrogram_from_wav()."        )    # check for the segments labeled as song from the groundtruth labels    padded = np.concatenate(([False], groundtruth_songs, [False]))    diff   = np.diff(padded.astype(int))    groundtruth_song_starts = np.where(diff == 1)[0]    groundtruth_song_ends   = np.where(diff == -1)[0]    # ── 2. z-scored log-amplitude trace ───────────────────────    band_mask = (frequencies >= amp_low_bandpass) & (frequencies <= amp_high_bandpass)    amp_band = (10 ** (spectrogram[band_mask, :] / 10)).sum(axis=0)    log_amp_band = np.log10(amp_band + eps)    # Z-score first (raw trace)    z_log_amp_band_unsmoothed = (log_amp_band - log_amp_band.mean()) / log_amp_band.std()    # Smooth it    z_log_amp_band_smoothed = gaussian_filter1d(z_log_amp_band_unsmoothed, sigma=smoothing_sigma_amplitude)        #Find detected songs using the smoothed amplitude    amplitude_detected_mask = z_log_amp_band_smoothed > amp_threshold    amplitude_detected_song_times = []    in_span = False    for i, flag in enumerate(amplitude_detected_mask):        if flag and not in_span:            in_span = True            span_start = times[i]        elif not flag and in_span:            span_end = times[i]            amplitude_detected_song_times.append((span_start, span_end))            in_span = False    if in_span:        amplitude_detected_song_times.append((span_start, times[-1]))    # ── 3. Envelope spectrogram of the amplitude trace ────────    #     NEW: derive sampling rate from the 'times' vector itself    if len(times) > 1:        dt     = np.mean(np.diff(times))        amp_fs = 1.0 / dt    else:  # degenerate fallback        amp_fs = len(times) / segment_duration    nperseg  = 128    pad_len  = nperseg // 2    trace_pad = np.pad(z_log_amp_band_unsmoothed, pad_len, mode="edge") #use the unsmoothed amplitude to calculate periodicity    f_env, t_env_raw, S_env = _spectrogram(        trace_pad,        fs=amp_fs,        window="hann",        nperseg=nperseg,        noverlap=96,    )    t_env = t_env_raw - (pad_len / amp_fs)        # shift time axis to undo padding    valid = (t_env >= times[0]) & (t_env <= times[-1])    t_env = t_env[valid]    S_env = S_env[:, valid]    S_env_norm = (S_env - S_env.min()) / (S_env.max() - S_env.min() + eps)    # ── 4. Periodicity traces ─────────────────────────────────    pow_full       = S_env_norm.sum(axis=0)    pow_full_norm  = (pow_full - pow_full.min()) / (pow_full.max() - pow_full.min() + eps)    periodicity_full = gaussian_filter1d(pow_full_norm, sigma=smoothing_sigma_periodicity)    mod_mask = (f_env >= low_mod) & (f_env <= high_mod)    pow_bp       = S_env_norm[mod_mask].sum(axis=0)    pow_bp_norm  = (pow_bp - pow_bp.min()) / (pow_bp.max() - pow_bp.min() + eps)    periodicity_bandpass = gaussian_filter1d(pow_bp_norm, sigma=smoothing_sigma_periodicity)        # ── 5. Periodicity-based detection spans ──────────────────────    periodicity_detected_mask = periodicity_bandpass > power_threshold    periodicity_detected_song_times = []  # ← your new output variable    in_span = False        for i, flag in enumerate(periodicity_detected_mask):        if flag and not in_span:            in_span = True            span_start = t_env[i]        elif not flag and in_span:            span_end = t_env[i]            periodicity_detected_song_times.append((span_start, span_end))  # ⬅ add segment            in_span = False    if in_span:        periodicity_detected_song_times.append((span_start, times[-1]))  # ⬅ add final segment     # ── 7. Amnplitude plot (optional) ─────────────────────────    if plot_amplitude_figure:       fig, axs = plt.subplots(           2, 1, figsize=(10, 6), sharex=True,           gridspec_kw=dict(height_ratios=[1, 2])       )          ticks = np.linspace(times[0], times[-1], 6)          # panel 1: z-log trace       axs[0].plot(times, z_log_amp_band_unsmoothed, color="gray", alpha=0.5, label="Bandpass filtered")       axs[0].plot(times, z_log_amp_band_smoothed, color="black", label=f"Bandpassed & smooth (σ={smoothing_sigma_amplitude})")       axs[0].axhline(amp_threshold, color="red", linestyle="--", label="Amplitude threshold")       axs[0].set_ylabel("z-log Σ power")       axs[0].legend(fontsize="x-small", loc="upper right")          # highlight amplitude-detected spans on panel 1       for (span_start, span_end) in amplitude_detected_song_times:           axs[0].axvspan(span_start, span_end, color="yellow", alpha=0.3)          # panel 2: spectrogram with highlighted song       mesh = axs[1].pcolormesh(           times,           frequencies,           spectrogram,           shading='auto',           cmap='binary'       )              axs[1].set_ylabel("Frequency bins from song labeler")       axs[1].set_ylim(amp_low_bandpass, amp_high_bandpass+50)       axs[1].set_xlabel("Time (s)")          # highlight amplitude-detected spans on panel 2       for (span_start, span_end) in amplitude_detected_song_times:           axs[1].axvspan(span_start, span_end, color="yellow", alpha=0.3)       for ax in axs:        ax.set_xticks(ticks)        ax.tick_params(axis="x", labelbottom=True)        if isinstance(input_data, str):        name_for_plot = Path(input_data).stem    else:        name_for_plot = "in-memory input"        fig.suptitle(f"Amplitude-based song detection for \n {name_for_plot}", y=1.02, fontsize=14, fontweight="bold")    fig.tight_layout()    plt.show()         # ── 7. Periodicity plot (optional) ─────────────────────────    if plot_periodicity_figure:        fig, axs = plt.subplots(            4, 1, figsize=(10, 9), sharex=True,            gridspec_kw=dict(height_ratios=[1, 1.5, 1, 2])        )        ticks = np.linspace(times[0], times[-1], 6)        # panel 1: z-log trace        #axs[0].set_ylabel("z-log Σ power")        #axs[0].plot(times, z_log_amp_band_unsmoothed, color="gray", alpha=0.5, label="Bandpass filtered")        #axs[0].plot(times, z_log_amp_band_smoothed, color="black", label=f"Bandpassed & smooth (σ={smoothing_sigma_amplitude})")        #axs[0].plot(times, z_log_amp_band_unsmoothed, color="black", alpha=0.5, label="Bandpass filtered")        #axs[0].set_ylabel("z-log Σ power")        #axs[0].legend(fontsize="x-small", loc="upper right")                # panel 1: z-log trace        axs[0].plot(times, z_log_amp_band_unsmoothed, color="black", alpha=0.5, label="Bandpass filtered")        axs[0].set_ylabel("z-log Σ power")        axs[0].legend(fontsize="x-small", loc="upper right")        # panel 2: envelope the spectrogram generated from the amplitude trace        axs[1].imshow(            S_env_norm, origin="lower", aspect="auto",            extent=[times[0], times[-1], f_env[0], f_env[-1]],            cmap="binary"        )        axs[1].set_ylim(0, max(high_mod * 1.1, 100))        axs[1].set_ylabel("Mod freq (Hz) of unsmoothed \n z-log-amplitude")        axs[1].axhline(low_mod,  color="red", ls="--")        axs[1].axhline(high_mod, color="red", ls="--")        # panel 3: band-pass periodicity        axs[2].plot(t_env, pow_bp_norm,          color="gray", alpha=0.6, label="Bandpass filtered")        axs[2].plot(t_env, periodicity_bandpass, color="black", label=f"Bandpassed & smooth (σ={smoothing_sigma_periodicity})")        axs[2].axhline(power_threshold, color="red", ls="--", label="Thresh")        axs[2].set_ylabel("Periodicity")        axs[2].legend(fontsize="x-small")        # panel 4: original spectrogram        mesh = axs[3].pcolormesh(            times,            frequencies,            spectrogram,            shading='auto',            cmap='binary')        axs[3].set_ylabel("Frequency (Hz)")        axs[3].set_ylim(0, 450)        axs[3].set_xlabel("Time (s)")        #fig.colorbar(mesh, ax=axs[3], label="Amplitude (dB)")        axs[3].set_ylabel("Frequency bins from song labeler")        #axs[3].set_ylim(0, 500)        axs[3].set_xlabel("Time (s)")        # highlight detected spans        for (span_start, span_end) in periodicity_detected_song_times:            for ax in (axs[2], axs[3]):                ax.axvspan(span_start, span_end, color="yellow", alpha=0.3)                                for ax in axs:                    ax.set_xticks(ticks)                    ax.tick_params(axis="x", labelbottom=True)                #name the plot after the .npz file (or, alternatively, the aray you generated the data with)        #if isinstance(input_data, str):        #    name_for_plot = Path(input_data).stem        #else:        #    name_for_plot = "in-memory input"        fig.suptitle(f"Periodicity-based song detection for \n {name_for_plot}", y=1.02, fontsize=14, fontweight="bold")        fig.tight_layout()        plt.show()            # ── 8. Package results ────────────────────────────────────    return SpectrogramData(        spectrogram                     = spectrogram,        frequencies                     = frequencies,        times                           = times,        groundtruth_songs               = groundtruth_songs,        groundtruth_song_starts         = groundtruth_song_starts,        groundtruth_song_ends           = groundtruth_song_ends,        z_log_amp_band_unsmoothed       = z_log_amp_band_unsmoothed,        z_log_amp_band_smoothed         = z_log_amp_band_smoothed,        amplitude_detected_song_times   = amplitude_detected_song_times,        envelope_spectrogram            = S_env_norm,        periodicity_full                = periodicity_full,        periodicity_bandpass            = periodicity_bandpass,        periodicity_detected_song_times = periodicity_detected_song_times,        #amp_low_bandpass                = amp_low_bandpass,        #amp_high_bandpass               = amp_high_bandpass,        #amp_threshold                   = amp_threshold,        #low_mod                         = low_mod,        #high_mod                        = high_mod,        #smoothing_sigma_amplitude       = smoothing_sigma_amplitude,        #smoothing_sigma_periodicity     = smoothing_sigma_periodicity,        #power_threshold                 = power_threshold,        #segment_duration                = segment_duration,             )