#!/usr/bin/env python# -*- coding: utf-8 -*-"""Calculate amplitude, periodicity, and Wiener-entropy features …"""from __future__ import annotationsfrom pathlib import Pathfrom typing import Optional, Union, Dict, Anyimport numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfilefrom scipy.signal import spectrogram as _spectrogram, windows, ellip, filtfiltfrom scipy.ndimage import gaussian_filter1d# ════════════════════════════════════════════════════════════════# Data container# ════════════════════════════════════════════════════════════════class SpectrogramData:    def __init__(        self,        s, f, t,        songs, starts, ends,        wiener_entropy,        z_log_amp_trace,        envelope_spectrogram,        periodicity_full,        periodicity_bandpass,    ):        self.s  = s        self.f  = f        self.t  = t        self.songs  = songs        self.starts = starts        self.ends   = ends        self.wiener_entropy       = wiener_entropy        self.z_log_amp_trace      = z_log_amp_trace        self.envelope_spectrogram = envelope_spectrogram        self.periodicity_full     = periodicity_full        self.periodicity_bandpass = periodicity_bandpass# ════════════════════════════════════════════════════════════════# Helper – build a *normalised* spectrogram from a .wav# ════════════════════════════════════════════════════════════════def _spectrogram_from_wav(    wav_path: Path,    low_cut: float,    high_cut: float,    nperseg: int = 2048,    noverlap: int = 2048 - 119,    gamma: float = 0.7,    floor_db: float = 3.0,):    sr, data = wavfile.read(wav_path)    if data.ndim > 1:        data = data.mean(axis=1)    if np.issubdtype(data.dtype, np.integer):        data = data.astype(np.float32)    nyq = sr / 2    b, a = ellip(5, 0.2, 40, [low_cut / nyq, high_cut / nyq], btype="band")    data = filtfilt(b, a, data)    f, t, Sxx = _spectrogram(        data,        fs=sr,        window=windows.gaussian(nperseg, std=nperseg / 8),        nperseg=nperseg,        noverlap=noverlap,        mode="magnitude",    )    eps = np.finfo(float).eps    S_log = 20 * np.log10(Sxx + eps)    S_log = np.clip(S_log, a_min=floor_db, a_max=None)    S_norm = (S_log - S_log.min()) / (np.ptp(S_log) or 1)    S_norm = S_norm.astype(np.float32) ** gamma    return S_norm, f, t# ════════════════════════════════════════════════════════════════# Main function# ════════════════════════════════════════════════════════════════def calculate_spectrogram_amp_periodicity_entropy(    source: Union[str, Path, Dict[str, Any]],    plot_figures: bool = True,    low_mod: float = 10,    high_mod: float = 50,    smoothing_sigma: float = 0.7,    power_threshold: float = 0.2,    segment_duration: Optional[float] = 10,    low_cut: float = 500,    high_cut: float = 8000,) -> SpectrogramData:    eps = np.finfo(float).eps    if isinstance(source, (str, Path)):        path = Path(source)        ext  = path.suffix.lower()        if ext == ".npz":            with np.load(path, allow_pickle=True) as data:                s_db = data["s"]                f = data["f"] if "f" in data.files else np.linspace(0, high_cut, s_db.shape[0])                t    = data["t"] if "t" in data.files else np.linspace(                    0, segment_duration or 10, s_db.shape[1], endpoint=False                )                songs = data["song"].astype(bool) if "song" in data.files else np.zeros(s_db.shape[1], bool)                clip_floor = 3.0                gamma = 0.7                s_clip = np.clip(s_db, a_min=clip_floor, a_max=None)                s_disp = (s_clip - s_clip.min()) / (np.ptp(s_clip) or 1)                s_disp **= gamma        elif ext == ".wav":            sr, wav = wavfile.read(path)            if wav.ndim > 1:                wav = wav.mean(axis=1)            if np.issubdtype(wav.dtype, np.integer):                wav = wav.astype(np.float32)            nyq = sr / 2            b, a = ellip(5, 0.2, 40, [low_cut / nyq, high_cut / nyq], btype="band")            wav  = filtfilt(b, a, wav)            f, t, Sxx = _spectrogram(                wav,                fs=sr,                window=windows.gaussian(2048, std=2048 / 8),                nperseg=2048,                noverlap=2048 - 119,                mode="magnitude",            )            s_db  = 20 * np.log10(Sxx + eps)            clip_floor = 3.0            gamma = 0.7            s_clip = np.clip(s_db, a_min=clip_floor, a_max=None)            s_disp = (s_clip - s_clip.min()) / (np.ptp(s_clip) or 1)            s_disp **= gamma            songs = np.zeros(s_db.shape[1], dtype=bool)            if segment_duration is None:                segment_duration = t[-1]        else:            raise ValueError("Path must point to a .npz or .wav file")        name_for_plot = path.name    elif isinstance(source, dict):        s_db = source["spectrogram"]        f = source["frequencies"]        t = source["times"]        songs = source.get("songs", np.zeros(s_db.shape[1], dtype=bool))        p_lo, p_hi = np.percentile(s_db, [5, 99])        s_clip = np.clip(s_db, p_lo, p_hi)        s_disp = (s_clip - p_lo) / (p_hi - p_lo + eps)        s_disp **= 0.7        name_for_plot = "<in-memory spectrogram>"    else:        raise TypeError("source must be path-like or a dict with spectrogram data")    lin_power = 10 ** (s_db / 10)    log_amp = np.log10(lin_power.sum(axis=0) + eps)    z_log_amp = gaussian_filter1d(        (log_amp - log_amp.mean()) / (log_amp.std() + eps),        sigma=smoothing_sigma,    )    geo_mean = np.exp(np.mean(np.log(lin_power + eps), axis=0))    arith_mean = lin_power.mean(axis=0) + eps    wiener_entropy = gaussian_filter1d(geo_mean / arith_mean, sigma=smoothing_sigma)    padded = np.concatenate(([False], songs, [False]))    starts = np.flatnonzero(np.diff(padded.astype(int)) == 1)    ends = np.flatnonzero(np.diff(padded.astype(int)) == -1)    if len(t) > 1:        dt = np.mean(np.diff(t))        amp_fs = 1.0 / dt    else:        amp_fs = len(t) / (segment_duration or 10)    nperseg_env = 128    pad_len = nperseg_env // 2    trace_pad = np.pad(z_log_amp, pad_len, mode="edge")    f_env, t_env_raw, S_env = _spectrogram(        trace_pad, fs=amp_fs, window="hann", nperseg=nperseg_env, noverlap=96    )    t_env = t_env_raw - (pad_len / amp_fs)    mask = (t_env >= t[0]) & (t_env <= t[-1])    t_env, S_env = t_env[mask], S_env[:, mask]    S_env_norm = (S_env - S_env.min()) / (S_env.max() - S_env.min() + eps)    full_raw = S_env_norm.sum(axis=0)    full_norm = (full_raw - full_raw.min()) / (np.ptp(full_raw) + eps)    periodicity_full = gaussian_filter1d(full_norm, sigma=smoothing_sigma)    mod_mask = (f_env >= low_mod) & (f_env <= high_mod)    bp_raw = S_env_norm[mod_mask].sum(axis=0)    bp_norm = (bp_raw - bp_raw.min()) / (np.ptp(bp_raw) + eps)    periodicity_bandpass = gaussian_filter1d(bp_norm, sigma=smoothing_sigma)    if plot_figures:        fig, axs = plt.subplots(5, 1, figsize=(10, 11), sharex=True,                                gridspec_kw=dict(height_ratios=[1, 1, 1.5, 1, 2]))        ticks = np.linspace(t[0], t[-1], 6)        axs[0].plot(t, wiener_entropy, color="black")        axs[0].set_ylabel("Wiener\nentropy")        axs[0].set_ylim(-0.1, 1.10)        axs[1].plot(t, z_log_amp, color="black")        axs[1].set_ylabel("z-log \u03a3 power")        axs[2].imshow(S_env_norm, origin="lower", aspect="auto",                     extent=[t[0], t[-1], f_env[0], f_env[-1]], cmap="binary")        axs[2].set_ylim(0, max(high_mod * 1.1, 40))        axs[2].set_ylabel("Mod freq (Hz)")        axs[2].axhline(low_mod, color="red", ls="--")        axs[2].axhline(high_mod, color="red", ls="--")        axs[3].plot(t_env, bp_norm, color="gray", alpha=0.6, label="Raw")        axs[3].plot(t_env, periodicity_bandpass, color="black", label="Smoothed")        axs[3].axhline(power_threshold, color="red", ls="--", label="Thresh")        axs[3].set_ylabel("Periodicity")        axs[3].legend(fontsize="x-small")        axs[4].imshow(s_disp, origin="lower", aspect="auto",                     extent=[t[0], t[-1], f[0], f[-1]], cmap="binary", vmin=0, vmax=1)        detect = periodicity_bandpass > power_threshold        in_span = False        for i, flag in enumerate(detect):            if flag and not in_span:                in_span, start = True, t_env[i]            elif not flag and in_span:                for ax in (axs[3], axs[4]):                    ax.axvspan(start, t_env[i], color="yellow", alpha=0.3)                in_span = False        if in_span:            for ax in (axs[3], axs[4]):                ax.axvspan(start, t[-1], color="yellow", alpha=0.3)        for ax in axs:            ax.set_xticks(ticks)            ax.tick_params(axis="x", labelbottom=True)        fig.suptitle(name_for_plot, y=1.02, fontsize=14, fontweight="bold")        fig.tight_layout()        plt.show()    return SpectrogramData(        s=s_db,        f=f,        t=t,        songs=songs,        starts=starts,        ends=ends,        wiener_entropy=wiener_entropy,        z_log_amp_trace=z_log_amp,        envelope_spectrogram=S_env_norm,        periodicity_full=periodicity_full,        periodicity_bandpass=periodicity_bandpass,    )## why is this running into trouble with .wav files??#from calculate_spectrogram_amp_periodicity_entropy import calculate_spectrogram_amp_periodicity_entropy#import calculate_spectrogram_amp_periodicity_entropy as cape#reload(cape)        # re-executes the file so both class & function are fresh#npz_path = "/path/to/your_file.npz"#features = cape.calculate_spectrogram_amp_periodicity_entropy(#    npz_path,#    plot_figures=True      # turn off if you don’t want the 5-panel diagnostic#)#wav_path = "/path/to/your_audio.wav"#features = calculate_spectrogram_amp_periodicity_entropy(wav_path,plot_figures=True)