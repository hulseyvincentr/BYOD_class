#!/usr/bin/env python# -*- coding: utf-8 -*-"""Visualise a pre-computed spectrogram (.npz) and compute    • Wiener-entropy trace               (NEW)    • z-scored log-amplitude trace    • amplitude-envelope spectrogram (0–1)    • periodicity_full      : sum across *all* modulation frequencies    • periodicity_bandpass  : sum across low_mod–high_mod HzThe function returns everything in a SpectrogramData object and, if`plot_figures=True`, draws a 5-panel diagnostic figure."""from pathlib import Pathfrom typing  import Optionalimport numpy as npimport matplotlib.pyplot as pltfrom scipy.ndimage import gaussian_filter1dfrom scipy.signal  import spectrogram# ════════════════════════════════════════════════════════════════# Data container# ════════════════════════════════════════════════════════════════class SpectrogramData:    def __init__(        self,        s, f, t,                       # spectrogram axes        songs, starts, ends,           # binary mask + segment indices        wiener_entropy,                # 1-D Wiener-entropy trace   (NEW)        z_log_amp_trace,               # 1-D z-scored log-amp trace        envelope_spectrogram,          # 2-D normalised envelope spec        periodicity_full,              # full-band periodicity trace        periodicity_bandpass           # band-pass periodicity trace    ):        self.s  = s        self.f  = f        self.t  = t        self.songs  = songs        self.starts = starts        self.ends   = ends        self.wiener_entropy      = wiener_entropy      # NEW        self.z_log_amp_trace     = z_log_amp_trace        self.envelope_spectrogram = envelope_spectrogram        self.periodicity_full     = periodicity_full        self.periodicity_bandpass = periodicity_bandpass# ════════════════════════════════════════════════════════════════# Main function# ════════════════════════════════════════════════════════════════def calculate_spectrogram_amp_periodicity_entropy(    npz_path: str | Path,    plot_figures: bool = True,    low_mod: float = 10,    high_mod: float = 30,    smoothing_sigma: float = 0.7,    power_threshold: float = 0.2,    segment_duration: float = 10,) -> SpectrogramData:    """    Parameters    ----------    npz_path : str | Path        Path to the .npz with keys 's' (dB spectrogram) and 'song' mask.    plot_figures : bool        Draw the 5-panel figure if True.    low_mod, high_mod : float        Band-pass limits (Hz) for periodicity_bandpass.    smoothing_sigma : float        σ for Gaussian smoothing of traces.    power_threshold : float        Threshold applied to periodicity_bandpass (only for highlight).    segment_duration : float        Duration of recording segment in seconds (if no 't' vector).    Returns    -------    SpectrogramData    """    # ── 1. Load data ───────────────────────────────────────────    npz_path = Path(npz_path)    with np.load(npz_path, allow_pickle=True) as data:        s = data["s"]                                # dB spectrogram (freq × time)        f = data["f"] if "f" in data.files else np.arange(s.shape[0])        t = (            data["t"]            if "t" in data.files            else np.linspace(0, segment_duration, s.shape[1], endpoint=False)        )        songs = data["song"].astype(bool)    # indices of contiguous song segments    padded = np.concatenate(([False], songs, [False]))    diff   = np.diff(padded.astype(int))    starts = np.where(diff == 1)[0]    ends   = np.where(diff == -1)[0]    eps = np.finfo(float).eps                       # numerical safety    # ── 2a. z-scored log-amplitude trace ──────────────────────    lin_power = 10 ** (s / 10)                      # convert dB → linear power    amp_sum   = lin_power.sum(axis=0) + eps    log_amp   = np.log10(amp_sum)    z_log_amp = gaussian_filter1d(        (log_amp - log_amp.mean()) / log_amp.std(), sigma=smoothing_sigma    )    # ── 2b. Wiener-entropy (spectral flatness) trace ──────────  NEW    geo_mean = np.exp(np.mean(np.log(lin_power + eps), axis=0))    arith_mean = lin_power.mean(axis=0) + eps    wiener_entropy_raw = geo_mean / arith_mean           # 0 ≤ WE ≤ 1    wiener_entropy = gaussian_filter1d(        wiener_entropy_raw, sigma=smoothing_sigma    )    # ── 3. Envelope spectrogram (with NFFT/2 padding) ─────────    amp_fs  = len(t) / segment_duration    nperseg = 128    pad_len = nperseg // 2    trace_pad = np.pad(z_log_amp, pad_len, mode="edge")    f_env, t_env_raw, S_env = spectrogram(        trace_pad,        fs=amp_fs,        window="hann",        nperseg=nperseg,        noverlap=96,    )    # align time axis with original timeline    t_env_shift = t_env_raw - (pad_len / amp_fs)    mask        = (t_env_shift >= t[0]) & (t_env_shift <= t[-1])    t_env       = t_env_shift[mask]    S_env       = S_env[:, mask]    # normalise entire envelope spectrogram to 0–1    S_env_norm = (S_env - S_env.min()) / (S_env.max() - S_env.min() + eps)    # ── 4. Periodicity traces ─────────────────────────────────    # 4a) full-band    pow_full      = S_env_norm.sum(axis=0)    pow_full_norm = (pow_full - pow_full.min()) / (pow_full.max() - pow_full.min() + eps)    periodicity_full = gaussian_filter1d(pow_full_norm, sigma=smoothing_sigma)    # 4b) band-pass    mod_mask   = (f_env >= low_mod) & (f_env <= high_mod)    pow_bp     = S_env_norm[mod_mask, :].sum(axis=0)    pow_bp_norm = (pow_bp - pow_bp.min()) / (pow_bp.max() - pow_bp.min() + eps)    periodicity_bandpass = gaussian_filter1d(pow_bp_norm, sigma=smoothing_sigma)    # ── 5. Plotting (optional) ────────────────────────────────    if plot_figures:        fig, axs = plt.subplots(            5, 1, figsize=(10, 11), sharex=True,            gridspec_kw=dict(height_ratios=[1, 1, 1.5, 1, 2])        )        # common x-ticks        ticks  = np.linspace(0, segment_duration, 6)        labels = [f"{x:.1f}" for x in ticks]        # panel 0: Wiener-entropy        axs[0].plot(t, wiener_entropy, color="black")        axs[0].set_ylabel("Wiener\nentropy")        axs[0].set_ylim(-0.01, 1.01)        axs[0].set_title("Spectral flatness (Wiener entropy)")        # panel 1: z-log trace        axs[1].plot(t, z_log_amp, color="black")        axs[1].set_ylabel("z-log Σ power")        axs[1].set_title("Z-scored log-amplitude trace")        # panel 2: envelope spectrogram (0–1)        axs[2].imshow(            S_env_norm,            origin="lower", aspect="auto",            extent=[t[0], t[-1], f_env[0], f_env[-1]],            cmap="binary"        )        axs[2].set_ylim(0, 40)        axs[2].set_ylabel("Mod freq (Hz)")        axs[2].set_title("Amplitude-envelope spectrogram (normalized)")        # red dashed cut-off lines + legend        h1 = axs[2].axhline(            low_mod if low_mod > 0 else 0.5,            color="red", ls="--", lw=1.2,            label=f"low_mod = {low_mod} Hz"        )        h2 = axs[2].axhline(            high_mod if high_mod < 40 else 39.5,            color="red", ls="--", lw=1.2,            label=f"high_mod = {high_mod} Hz"        )        axs[2].legend(handles=[h1, h2], loc="upper right",                      fontsize="x-small", frameon=False)        # panel 3: band-pass periodicity        axs[3].plot(t_env, pow_bp_norm,      color="gray", alpha=0.7, label="Raw (norm)")        axs[3].plot(t_env, periodicity_bandpass, color="black",            label="Smoothed")        axs[3].axhline(power_threshold, color="red", ls="--", label="Threshold")        axs[3].set_ylabel("Periodicity")        axs[3].set_title(f"Periodicity trace ({low_mod}–{high_mod} Hz band)")        axs[3].legend(fontsize="x-small", loc="upper right")        # panel 4: original spectrogram + detections        S_norm = (s - s.min()) / (s.max() - s.min() + eps)        axs[4].imshow(            S_norm,            origin="lower", aspect="auto",            extent=[t[0], t[-1], f[0], f[-1]],            cmap="binary"        )        axs[4].set_ylabel("Freq bin")        axs[4].set_xlabel("Time (s)")        axs[4].set_title("Original spectrogram (detected song highlighted)")        # highlight detected spans (band-pass trace)        detect  = periodicity_bandpass > power_threshold        in_span = False        for idx, flag in enumerate(detect):            if flag and not in_span:                in_span, span_start = True, t_env[idx]            elif not flag and in_span:                for ax in (axs[3], axs[4]):                    ax.axvspan(span_start, t_env[idx], color="yellow", alpha=0.3)                in_span = False        if in_span:            for ax in (axs[3], axs[4]):                ax.axvspan(span_start, t[-1], color="yellow", alpha=0.3)        # apply x-ticks to every axis        for ax in axs:            ax.set_xticks(ticks)            ax.set_xticklabels(labels)            ax.tick_params(axis="x", labelbottom=True)        plt.tight_layout()        fig.suptitle(f"{npz_path.name}", fontsize=14, fontweight="bold", y=1.02)        plt.show()    # ── 6. Return results ─────────────────────────────────────    return SpectrogramData(        s=s, f=f, t=t,        songs=songs, starts=starts, ends=ends,        wiener_entropy=wiener_entropy,            # NEW        z_log_amp_trace=z_log_amp,        envelope_spectrogram=S_env_norm,        periodicity_full=periodicity_full,        periodicity_bandpass=periodicity_bandpass    )