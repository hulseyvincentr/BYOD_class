#!/usr/bin/env python# -*- coding: utf-8 -*-"""Calculate amplitude, periodicity, and Wiener-entropy features …"""from __future__ import annotationsfrom pathlib import Pathfrom typing import Optional, Union, Dict, Any   #  ←  add / restore this lineimport numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfilefrom scipy.signal import spectrogram as _spectrogram, windows, ellip, filtfiltfrom scipy.ndimage import gaussian_filter1d# ════════════════════════════════════════════════════════════════# Data container# ════════════════════════════════════════════════════════════════class SpectrogramData:    def __init__(        self,        s, f, t,        songs, starts, ends,        wiener_entropy,        z_log_amp_trace,        envelope_spectrogram,        periodicity_full,        periodicity_bandpass,    ):        self.s  = s        self.f  = f        self.t  = t        self.songs  = songs        self.starts = starts        self.ends   = ends        self.wiener_entropy       = wiener_entropy        self.z_log_amp_trace      = z_log_amp_trace        self.envelope_spectrogram = envelope_spectrogram        self.periodicity_full     = periodicity_full        self.periodicity_bandpass = periodicity_bandpass# ════════════════════════════════════════════════════════════════# Helper – build a *normalised* spectrogram from a .wav# ════════════════════════════════════════════════════════════════from scipy.signal import spectrogram as _spectrogram, windows, ellip, filtfiltfrom scipy.io    import wavfileimport numpy as npdef _spectrogram_from_wav(    wav_path: Path,    low_cut: float,    high_cut: float,    nperseg: int = 2048,    noverlap: int = 2048 - 119,    gamma: float = 0.7,           # perceptual contrast    floor_db: float = 3.0,        # dB floor (white background)):    """    Return (S_norm, f, t) where S_norm is *already* in [0, 1] and gamma-corrected.    """    sr, data = wavfile.read(wav_path)    if data.ndim > 1:        data = data.mean(axis=1)    if np.issubdtype(data.dtype, np.integer):        data = data.astype(np.float32)    # ── band-pass ───────────────────────────────────────────────    nyq = sr / 2    b, a = ellip(5, 0.2, 40, [low_cut / nyq, high_cut / nyq], btype="band")    data = filtfilt(b, a, data)    # ── magnitude spectrogram ──────────────────────────────────    f, t, Sxx = _spectrogram(        data,        fs=sr,        window=windows.gaussian(nperseg, std=nperseg / 8),        nperseg=nperseg,        noverlap=noverlap,        mode="magnitude",    )    # ── log-scale + contrast stretch ───────────────────────────    eps = np.finfo(float).eps    S_log = 20 * np.log10(Sxx + eps)    S_log = np.clip(S_log, a_min=floor_db, a_max=None)      # floor → white    S_norm = (S_log - S_log.min()) / (np.ptp(S_log) or 1)    S_norm = S_norm.astype(np.float32) ** gamma             # perceptual ramp    return S_norm, f, t# ════════════════════════════════════════════════════════════════# Main function# ════════════════════════════════════════════════════════════════def calculate_spectrogram_amp_periodicity_entropy(    source: Union[str, Path, Dict[str, Any]],    plot_figures: bool = True,    low_mod: float = 10,    high_mod: float = 50,    smoothing_sigma: float = 0.7,    power_threshold: float = 0.2,    segment_duration: Optional[float] = 10,   # still used only when no time axis exists    low_cut: float = 500,    high_cut: float = 8000,) -> SpectrogramData:    """    `source` can be:        • Path / str to a .npz        • Path / str to a .wav        • dict with keys 'spectrogram', 'frequencies', 'times'    """    eps = np.finfo(float).eps    # ── 1. Acquire spectrogram (analysis + display versions) ──────    if isinstance(source, (str, Path)):        path = Path(source)        ext  = path.suffix.lower()            if ext == ".npz":            # file already stores a dB spectrogram            with np.load(path, allow_pickle=True) as data:                s_db = data["s"]                                            # ← dB                f    = data["f"] if "f" in data.files else np.arange(s_db.shape[0])                t    = data["t"] if "t" in data.files else np.linspace(                          0, segment_duration or 10, s_db.shape[1], endpoint=False                       )                songs = data["song"].astype(bool) if "song" in data.files else np.zeros(s_db.shape[1], bool)            elif ext == ".wav":            # build magnitude → dB → display copy            sr, wav = wavfile.read(path)            if wav.ndim > 1:                wav = wav.mean(axis=1)            if np.issubdtype(wav.dtype, np.integer):                wav = wav.astype(np.float32)                nyq = sr / 2            b, a = ellip(5, 0.2, 40, [low_cut/nyq, high_cut/nyq], btype="band")            wav  = filtfilt(b, a, wav)                f, t, Sxx = _spectrogram(                wav,                fs=sr,                window=windows.gaussian(2048, std=2048/8),                nperseg=2048,                noverlap=2048-119,                mode="magnitude",            )                eps   = np.finfo(float).eps            s_db  = 20 * np.log10(Sxx + eps)            # ← analysis copy                # display copy (clip + gamma)            clip_floor = 3.0            gamma      = 0.7            s_clip = np.clip(s_db, a_min=clip_floor, a_max=None)            s_disp = (s_clip - s_clip.min()) / (np.ptp(s_clip) or 1)            s_disp **= gamma                songs = np.zeros(s_db.shape[1], dtype=bool)            if segment_duration is None:                segment_duration = t[-1]            else:            raise ValueError("Path must point to a .npz or .wav file")            name_for_plot = path.name        elif isinstance(source, dict):        s_db   = source["spectrogram"]                       # assume dB        f      = source["frequencies"]        t      = source["times"]        songs  = source.get("songs", np.zeros(s_db.shape[1], dtype=bool))        # build display copy from s_db        # --- create display copy from s_db ---------------------------------        p_lo, p_hi = np.percentile(s_db, [5, 99])   # robust min / max        s_clip = np.clip(s_db, p_lo, p_hi)          # clip only extreme tails        s_disp = (s_clip - p_lo) / (p_hi - p_lo + eps)        s_disp **= 0.7                              # perceptual gamma        # -------------------------------------------------------------------        name_for_plot = "<in-memory spectrogram>"        else:        raise TypeError("source must be path-like or a dict with spectrogram data")        # ------------------------------------------------------------------    # Ensure a display spectrogram exists (needed for bottom panel)    if "s_disp" not in locals():        clip_floor = 3.0        gamma      = 0.7        s_clip = np.clip(s_db, a_min=clip_floor, a_max=None)        s_disp = (s_clip - s_clip.min()) / (np.ptp(s_clip) or 1)        s_disp **= gamma    # ------------------------------------------------------------------    # ── 2. Song-segment indices ───────────────────────────────    padded = np.concatenate(([False], songs, [False]))    starts = np.flatnonzero(np.diff(padded.astype(int)) ==  1)    ends   = np.flatnonzero(np.diff(padded.astype(int)) == -1)    # ── 3. Log-amp trace & Wiener entropy (use s_db) ──────────────    lin_power  = 10 ** (s_db / 10)              # convert dB → linear power    log_amp    = np.log10(lin_power.sum(axis=0) + eps)        z_log_amp  = gaussian_filter1d(        (log_amp - log_amp.mean()) / (log_amp.std() + eps),        sigma=smoothing_sigma,    )        geo_mean   = np.exp(np.mean(np.log(lin_power + eps), axis=0))    arith_mean = lin_power.mean(axis=0) + eps    wiener_entropy = gaussian_filter1d(        geo_mean / arith_mean,        sigma=smoothing_sigma,    )    geo_mean   = np.exp(np.mean(np.log(lin_power + eps), axis=0))    arith_mean = lin_power.mean(axis=0) + eps    wiener_entropy = gaussian_filter1d(geo_mean / arith_mean, sigma=smoothing_sigma)    # ── 4. Envelope spectrogram of amplitude trace ────────────    #     NEW: derive sampling rate from the 't' axis itself    if len(t) > 1:        dt     = np.mean(np.diff(t))        amp_fs = 1.0 / dt    else:                  # degenerate fallback — should almost never trigger        amp_fs = len(t) / (segment_duration or 10)    nperseg   = 128    pad_len   = nperseg // 2    trace_pad = np.pad(z_log_amp, pad_len, mode="edge")    f_env, t_env_raw, S_env = _spectrogram(        trace_pad, fs=amp_fs, window="hann", nperseg=nperseg, noverlap=96    )    t_env = t_env_raw - (pad_len / amp_fs)    mask  = (t_env >= t[0]) & (t_env <= t[-1])    t_env, S_env = t_env[mask], S_env[:, mask]    S_env_norm   = (S_env - S_env.min()) / (S_env.max() - S_env.min() + eps)    # ── 5. Periodicity traces ─────────────────────────────────    full_raw  = S_env_norm.sum(axis=0)    full_norm = (full_raw - full_raw.min()) / (np.ptp(full_raw) + eps)    periodicity_full = gaussian_filter1d(full_norm, sigma=smoothing_sigma)    mod_mask  = (f_env >= low_mod) & (f_env <= high_mod)    bp_raw    = S_env_norm[mod_mask].sum(axis=0)    bp_norm   = (bp_raw - bp_raw.min()) / (np.ptp(bp_raw) + eps)    periodicity_bandpass = gaussian_filter1d(bp_norm, sigma=smoothing_sigma)    # ── 6. Diagnostic plot (optional) ─────────────────────────    if plot_figures:        fig, axs = plt.subplots(            5, 1, figsize=(10, 11), sharex=True,            gridspec_kw=dict(height_ratios=[1, 1, 1.5, 1, 2])        )        ticks = np.linspace(t[0], t[-1], 6)        axs[0].plot(t, wiener_entropy, color="black")        axs[0].set_ylabel("Wiener\nentropy")        axs[0].set_ylim(-0.01, 1.01)        axs[1].plot(t, z_log_amp, color="black")        axs[1].set_ylabel("z-log Σ power")        axs[2].imshow(            S_env_norm, origin="lower", aspect="auto",            extent=[t[0], t[-1], f_env[0], f_env[-1]], cmap="binary"        )        axs[2].set_ylim(0, max(high_mod * 1.1, 40))        axs[2].set_ylabel("Mod freq (Hz)")        axs[2].axhline(low_mod,  color="red", ls="--")        axs[2].axhline(high_mod, color="red", ls="--")        axs[3].plot(t_env, bp_norm,             color="gray", alpha=0.6, label="Raw")        axs[3].plot(t_env, periodicity_bandpass, color="black",          label="Smoothed")        axs[3].axhline(power_threshold, color="red", ls="--", label="Thresh")        axs[3].set_ylabel("Periodicity")        axs[3].legend(fontsize="x-small")        axs[4].imshow(            s_disp, origin="lower", aspect="auto",            extent=[t[0], t[-1], f[0], f[-1]],            cmap="binary", vmin=0, vmax=1        )        # highlight detected spans        detect  = periodicity_bandpass > power_threshold        in_span = False        for i, flag in enumerate(detect):            if flag and not in_span:                in_span, start = True, t_env[i]            elif not flag and in_span:                for ax in (axs[3], axs[4]):                    ax.axvspan(start, t_env[i], color="yellow", alpha=0.3)                in_span = False        if in_span:            for ax in (axs[3], axs[4]):                ax.axvspan(start, t[-1], color="yellow", alpha=0.3)        for ax in axs:            ax.set_xticks(ticks)            ax.tick_params(axis="x", labelbottom=True)        fig.suptitle(name_for_plot, y=1.02, fontsize=14, fontweight="bold")        fig.tight_layout()        plt.show()    # ── 7. Return results ─────────────────────────────────────    # ------------------------------------------------------------------    # Ensure a display spectrogram exists (needed for bottom panel)    if "s_disp" not in locals():        clip_floor = 3.0        gamma      = 0.7        s_clip = np.clip(s_db, a_min=clip_floor, a_max=None)        s_disp = (s_clip - s_clip.min()) / (np.ptp(s_clip) or 1)        s_disp **= gamma    # ------------------------------------------------------------------        return SpectrogramData(        s=s_db,           # analysis spectrogram in dB        f=f,        t=t,        songs=songs,        starts=starts,        ends=ends,        wiener_entropy=wiener_entropy,        z_log_amp_trace=z_log_amp,        envelope_spectrogram=S_env_norm,        periodicity_full=periodicity_full,        periodicity_bandpass=periodicity_bandpass,    )#from calculate_spectrogram_amp_periodicity_entropy import calculate_spectrogram_amp_periodicity_entropy#import calculate_spectrogram_amp_periodicity_entropy as cape#reload(cape)        # re-executes the file so both class & function are fresh#npz_path = "/path/to/your_file.npz"#features = cape.calculate_spectrogram_amp_periodicity_entropy(#    npz_path,#    plot_figures=True      # turn off if you don’t want the 5-panel diagnostic#)#wav_path = "/path/to/your_audio.wav"#features = calculate_spectrogram_amp_periodicity_entropy(wav_path,plot_figures=True)